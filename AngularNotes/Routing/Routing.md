Для содания роутинга *РОДИТЕЛЬСКОГО КОМПОНЕНТА* в Ангулар необходимо содать отдельный routingModule либо зарекать роутер в appModule.
1) Импортируем *RouterModule* и *Routes* из *@angular/router* 
2) Создаем константу типа *Routes* и кладем в нее массив объектов.
3) В данном массиве свойство *Path* указывает на путь, который будет использован в качестве URL для перехода. *Components* указывает на компонет, который будет загружен при данном URL. *!Важно* в URL можно писать как абсолютный путь */url* так и относительный *ulr*. В первом случае путь будет составлять только то, что указано в path. Во втором же данный путь будет прибавлен к текущему адрессу, на котором открыт компонент.![[Pasted image 20220606115101.png]]
4) После того в иморты необходимо добавить метод *forRoot* модуля *RouterModule* и передать в него константу с путями![[Pasted image 20220606115323.png]]


Cтайлинг активных роутов.
Если необходимо задать стиль активной ссылке можно использовать директиву *[routerLinkActive]* ![[Pasted image 20220606115929.png]]
![[Pasted image 20220606115953.png]]
В данную дерективу передаем класс, который необходимо задать активному компоненту. *!ВАЖНО* на компонент, ссылка на которой является начальной всегда будет навешен данный класс, т.к его путь всегда будет являться частью пути для других компонентов. Чтобы это избежать используется директива *[routerLinkActiveOptions]* и передаем в нее объект с параметром *exact: true*. Это означает, что класс будет навешен только при полном совпадении пути.ч


Программная навигация.
Программная навигация необходима, если мы хотим перейти по другому url не по клику или ручному вводу в адрессную строку, а допустим после завершения каких либо вычислений или как реакция на какой то ивент.
Для этого необходимо инжектировать инстанс класса *Router* в компонент и использовать метод *navigate* в который передается массив строк-путей, по которому будет совершен переход. *!ВАЖНО* данный путь должен быть зарегистрирован в модуле роутинга, иначе будет ошибка.![[Pasted image 20220606121613.png]]
Кроме того у ментода *navigate* есть второй аргумент, который является конфигом для данного метода. Одним из свойств данного конфига является *relativeTo*. Т.к метод *navigate* используется из компонента,а не темплейта он не знает о текущем активном компоненте/URL. Для обозначения этого компонента необходимо инжектировать инстанс класса *ActivatedRoute* и задать его как значение для свойства *relativeTo*. В таком случае метод будет знать, относительно какого компонента будет задаваться путь. *!ВАЖНО* в дефолтном случае, без указаний данного конфиг-объекта путь будет считаться относительно родительсткого/рутового комонента.![[Pasted image 20220606123132.png]]


Задание динамически изменяемых параметров.
Иногда может понадобиться изменять url динамически для создания определенных путей, например указание id. Для реализации такого подхода необходимо создать новый объект в массиве с путями.![[Pasted image 20220606125043.png]]
: говорит о том, что данный параметр является динамичным. Можно задавать любое количество данных параметров.
Для возможности использования данных параметров необходимо использовать ранее упомянутый инстанс класса *ActivatedLinks* и использовать одно из его свойств *snapshot*, в котором можно получить доступ к параметрам через свойство *params*![[Pasted image 20220606130123.png]]


Реактивное изменение параметров.

Свойство *snapshot* подходит для перичной инициализации каких либо параметров, переданных в url. Но данное свойство не реактивно, т.е при изменении параметров из текущего компонента, данный в *snapshot* изменены не будут, т.к Ангулар не будет рендерить заново уже отрендереный компонент. Для отслеживания изменения данных существует реактивная версия *params*. ![[Pasted image 20220606131221.png]]
Отличие данных свойств в том, что *params* возврщает Observalbe.

Использование квериПараметров и фрагментов.

Для использования квериПараметров и фрагментов есть две возможности: через темплейт и через компонент. Для реализации через темплейт необходимо использоваться параметр [queryParams] дерективы [routerLink]![[Pasted image 20220606135642.png]]

Для реализации подхода из котроллера используем ранее упомянутый объект-конфиг метода *navigate*
![[Pasted image 20220606135815.png]]

Для получения этих параметров в контроллере как и с параметрами необходимо использовать инстанс класса *activatedLink*, свойство *snapshot* и его свойства *queryParams* и *fragment*. Но данный метод подходит только для начальной инициализации параметров, т.к они будут изменяться только в случае перерендера компонента. Для реактивного подхода же можно использовать одноименные свойства, но уже без *snapshot*.


Для создания роутов из чилдрен компонентов, необходимо задать свойство *children* в соответсвующем компоненте в массиве роутов.![[Pasted image 20220606173034.png]]
Кроме того, в темплейтах суб-родительских компонентов(user и servers в данном примере) необходимо указать router-outlet.
![[Pasted image 20220606173239.png]]


Создание 404 раута.
В случае попытки доступа к url, который не описан в массиве путей, приложение крашиться. Для предотвращения этого необходимо создать компонент нот-фаунд и прописать путь для него.
![[Pasted image 20220606174432.png]]
путь **  означает любой url и при переходе на него будет происходить перенаправление на компонент нот-фаунд. *!ВАЖНО* он обязательно должен быть послендним элементом иначе вы всегда будет перенаправлены на соответсвующий компонет.

GUARDS

Гуарды - это сервисы, которые отслеживают переходы на те или иные роуты. В зависимости от типа гуарда он срабатывает до перехода на роут либо при попытке покинуть текущий роут.

CanActivate - гуард, срабатывающий до перехода на роут и проверяющий можно ли пускать пользователя на данный роут.